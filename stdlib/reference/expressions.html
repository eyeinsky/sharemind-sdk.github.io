<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SecreC 2 language: Expressions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SecreC 2 language
   &#160;<span id="projectnumber">2.4.0 (2018.12)</span>
   </div>
   <div id="projectbrief">Language and standard library reference</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Expressions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Expressions in SecreC</p>
<h1><a class="anchor" id="expressions_section"></a>
Expressions</h1>
<p>Many of the expressions implicitly operate point-wise on arrays and, in many cases, scalar values are automatically converted into a higher-dimensional array, if the size of resulting array is derivable from the context. For example, if one argument of addition operator is matrix and other is constant scalar 1, then the scalar is converted into properly sized matrix before point-wise addition is performed. This feature is desirable in several data mining operations and simplifies the development of such code.</p>
<h2><a class="anchor" id="arithmetic_operators"></a>
Arithmetic Operators</h2>
<p>SecreC supports the following arithmetic operators:</p>
<ol type="1">
<li><code>+</code> for addition,</li>
<li><code>-</code> for subtraction,</li>
<li><code>*</code> for multiplication,</li>
<li><code>/</code> for division,</li>
<li><code>%</code> for integer modulo,</li>
<li><code>-</code> for numeric unary negation, and</li>
<li><code>++</code>,<code>--</code> for incrementing/decrementing integers.</li>
</ol>
<p>Arithmetic operators can be called on mixed security typed parameters. The resulting security type is always the stricter of parameters, and the value with the looser security type is implicitly classified. Calling binary operators on expressions of mixed data types, however, is forbidden, and requires explicit data type cast. The types of arithmetic operators are informally described in Table 1.</p>
<p>Table 1: Public scalar operator types</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Operator  </th><th class="markdownTableHeadLeft">Return  </th><th class="markdownTableHeadLeft">Parameters   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>!</code>  </td><td class="markdownTableBodyLeft"><b>bool</b>  </td><td class="markdownTableBodyLeft"><b>bool</b>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>&amp;&amp;,</code>||  </td><td class="markdownTableBodyLeft"><b>bool</b>  </td><td class="markdownTableBodyLeft"><b>bool</b>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>&amp;,</code>|<code>,^</code>  </td><td class="markdownTableBodyLeft">Argument type  </td><td class="markdownTableBodyLeft"><b>bool</b>, unsigned integer types   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>&lt;&lt;, &gt;&gt;, ~</code>  </td><td class="markdownTableBodyLeft">Argument type  </td><td class="markdownTableBodyLeft">Unsigned integer types   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>&lt;,&gt;,&lt;=,&gt;=,==,!=</code>  </td><td class="markdownTableBodyLeft"><b>bool</b>  </td><td class="markdownTableBodyLeft">Any types   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>+,-,*,/,%,++,--</code>  </td><td class="markdownTableBodyLeft">Argument type  </td><td class="markdownTableBodyLeft">Integer and floating-point types   </td></tr>
</table>
<h2><a class="anchor" id="relational_operators"></a>
Relational operators</h2>
<p>Following relational operators are supported:</p>
<ol type="1">
<li>equality <code>==</code>,</li>
<li>inequality <code>!=</code>,</li>
<li>less-than <code>&lt;</code>,</li>
<li>less-or-equal <code>&lt;=</code>,</li>
<li>greater-than <code>&gt;</code>, and</li>
<li>greater-or-equal <code>&gt;=</code>.</li>
</ol>
<p>Relational operators always return boolean value. Arguments can be of any built-in data type. Arguments have to be of the same data type, but can be called on mixed security types in which case the result is the stricter of the two. If needed scalars are implicitly converted to arrays.</p>
<h2><a class="anchor" id="logical_operators"></a>
Logical operators</h2>
<p>SecreC supports following Boolean logic operations for the <b>bool</b> data type:</p>
<ol type="1">
<li><code>&amp;&amp;</code> for conjunction,</li>
<li><code>||</code> for disjunction,</li>
<li><code>^</code> for exclusive-OR (XOR), and</li>
<li><code>!</code> for logical unary negation.</li>
</ol>
<p>All require arguments and return types to be boolean. As with arithmetic and relational expressions boolean expressions can be called on mixed security typed parameters, and implicit scalar to array conversion is performed when required. However, calling boolean expressions on mixed security types has an important caveat. It’s common for strict languages to evaluate logical boolean expressions lazily (known as <em>short-circuit evaluation</em> ). For example, if the first branch of conjunction expression evaluates to false the second branch is never evaluated. This is also the case in SecreC for boolean expressions called on public scalar values, but not if any of the arguments is private or scalar. The reason for this behavior is that any changes in control flow are publicly visible, and that can cause unwanted private data to leak into public space. To avoid leaking information in such manner, we do not support the short-circuited operators on private values. Bitwise conjunction and disjunction can be used instead which will evaluate to the same result but will always evaluate both branches. Due to the point-wise behavior a short-circuit evaluation is not possible for boolean expressions if one of the arguments is a non-scalar.</p>
<h2><a class="anchor" id="bitwise_operators"></a>
Bitwise operators</h2>
<p>The following operators are supported for bit manipulation of unsigned integer types:</p>
<ol type="1">
<li><code>&amp;</code> for bitwise AND,</li>
<li><code>|</code> for bitwise OR,</li>
<li><code>^</code> for bitwise exclusive-OR (XOR),</li>
<li><code>~</code> for the bitwise complement (flips all bits), and</li>
<li><code>&lt;&lt; , &gt;&gt;</code> for bitwise left shift and right shift respectively.</li>
</ol>
<p>Bitwise expressions can be called on mixed security typed parameters, and implicit scalar to array conversion is performed when required.</p>
<h2><a class="anchor" id="casting_operators"></a>
Casting operators</h2>
<p>SecreC does not support implicit type casts, but does support explicit C-style data-type conversion. To perform a type cast a parenthesised data-type is written before an expression. Non-zero integer typed values cast to <b>true</b> boolean type, and zero values casts to <b>false</b>. Conversely, booleans cast to 1 in case of <b>true</b> and 0 in case of <b>false</b>. Non-public data type conversions are allowed.</p>
<p>Listing 1: Data type conversion </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i = 0;</div><div class="line"><span class="keywordtype">bool</span> b = <span class="keyword">true</span>;</div><div class="line">b = (bool) i;</div></div><!-- fragment --><h2><a class="anchor" id="type_annotation"></a>
Type annotation</h2>
<p>Due to lack of implicit type casts, and support for function overloading by return type it’s sometimes required to specify a type of an expression explicitly. For example, if a procedure is over-loaded by multiple different return types, an explicit type annotation is required to disambiguate the function call. To annotate an expression with a type, the type is written after double colon following the expression. If the type annotation expression type checks, then it evaluates to given type.</p>
<p>Listing 2: Type annotations </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> g (<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y) { ... }</div><div class="line">sharemind_test_pd <span class="keywordtype">int</span> g (<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y) { ... }</div><div class="line"><span class="keywordtype">void</span> main () {</div><div class="line">        <span class="keywordtype">int</span> x, y;</div><div class="line">        f (g (x, y) :: sharemind_test_pd );</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ternary_operator"></a>
Ternary operator</h2>
<p>The ternary expressions take three arguments the first of which is a boolean value. If the first argument evaluates to <b>true</b> then the value of the second branch is returned. Otherwise, if the first argument evaluates to <b>false</b> , the value of the third branch is returned.</p>
<p>Listing 3: Use of ternary operator </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i = 1;</div><div class="line"><span class="keywordtype">int</span> x = i &lt; 1 ? 0 : 42;</div><div class="line"><span class="comment">// x == 42</span></div></div><!-- fragment --><p>Unlike with logical expressions, the boolean argument of ternary expression is forced to be of a public security type. Data and dimensionality types of branches are also forced to be equal. The resulting privacy type is the stricter of the two branches, and the looser type is implicitly classified. The dimensionalities of branches are forced to be equal because the shape of the resulting array might not be derivable by evaluating only one branch. Consider the case where a conditional expression evaluates to <b>true</b>, the first branch is scalar, but the second is a matrix. In that case, the scalar value will be required to be converted to constant array with the shape of the second branch, but in order to derive the shape of the second branch it needs to be evaluated. By forcing the branches to have same dimensionalities we can avoid such issues. Ternary expressions operate point-wise if the conditional expression is non-scalar. In order to avoid even more confusing semantics, we force the branches to have equal number of dimensions.</p>
<h2><a class="anchor" id="assignment_operators"></a>
Assignment operators</h2>
<p>An assignment expression evaluates the right hand side expression, and returns the value. After the evaluation the variable points to the computed value of the right hand side expression. In the case of arrays, even the shape of the left hand side is overwritten. The assignment operator is right-associative. The assignment operator can be used in conjunction with binary arithmetic operators to modify the variable. For example, to increment a variable i by two we can write i += 2 or, similarly, i -= 1 to decrement it by one. If the right hand side of any assignment expression is public, but the left hand side is non-public then the public data is first implicitly classified before the assignment is performed.</p>
<p>Listing 4: Assignment operators </p><div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keywordtype">int</span> i;</div><div class="line"><span class="keyword">private</span> <span class="keywordtype">int</span> secret ;</div><div class="line"><span class="comment">// some computation</span></div><div class="line">i += 5;</div><div class="line"> <span class="comment">// increment by 5</span></div><div class="line">secret = i; <span class="comment">// implicit classify</span></div></div><!-- fragment --><h2><a class="anchor" id="increment_decrement"></a>
Increment/decrement operators</h2>
<p>SecreC supports both prefix and postfix increment and decrement operators. We write ++ i or i ++ to increment a variable i by one. The difference between the two methods is that the prefix increment first increments the value and then returns it, while the postfix increment first returns a copy of the value of the variable and then increments it. The same holds for the decrement operator.</p>
<p>Listing 5: Increment and decrement operators </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i = 5;</div><div class="line"><span class="keywordtype">int</span> j;</div><div class="line">j = i ++; <span class="comment">// j == 5, i == 6</span></div><div class="line">j = 42; <span class="comment">// j == 42, i == 6</span></div><div class="line">j = -- i; <span class="comment">// j == 5, i == 5</span></div></div><!-- fragment --><h2><a class="anchor" id="declassify_operator"></a>
Declassify operator</h2>
<p>The only way to move private data into a public memory space is via the <b>declassify</b> operator. The declassify construct takes a private argument with any kind of data type and returns the value with the same data type in public security domain. In order to forbid expressions such as <b>declassify</b>(<b>declassify</b>(x)), the arguments of declassify are not implicitly classified.</p>
<p>Listing 6: Declassify example </p><div class="fragment"><div class="line"><span class="keyword">private</span> <span class="keywordtype">int</span> val;</div><div class="line"><span class="comment">// read the val from database</span></div><div class="line"><span class="comment">// do some computation on data</span></div><div class="line"><span class="keywordtype">bool</span> result = declassify (val &lt; 0);</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 3 2019 14:24:33 for SecreC 2 language by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
