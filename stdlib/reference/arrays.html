<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SecreC 2 language: Arrays</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SecreC 2 language
   &#160;<span id="projectnumber">2.2.1 (2018.06)</span>
   </div>
   <div id="projectbrief">Language and standard library reference</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Arrays </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Arrays in SecreC</p>
<h1><a class="anchor" id="arrays_section"></a>
Arrays</h1>
<p>SecreC is strongly focused on arrays, and the majority of arithmetic, relational and logical operations operate point-wise on them. The main motivation for this behaviour is that private operations are individually slow on some protection domain implementations, and usually require a great deal of network communication overhead. Performing private operations in parallel reduces the time cost involved.The network communication cost is reduced too, as it’s more efficient to send data in bulk rather than sending small packets individually for each operation. SecreC supports multidimensional rectangular arrays. The arrays are more similar to those in Fortran than those in C or Java. The main difference is that multi dimensional arrays in both C and Java are so called Iliffe vectors [Ili61] storing single dimensional vector of pointers to arrays of one dimension less. Like in Fortran arrays in SecreC are always stored as a contiguous block of memory. Every array is associated with sizes of all its dimensions, we call tuple of those a shape of the array. The shape, unlike dimensionality, is a dynamic property and can freely change in the process of program evaluation. The shape is also always a public property, even for arrays containing private data.</p>
<h2><a class="anchor" id="assigning_arrays"></a>
Assigning arrays</h2>
<p>There are two ways to assign arrays. If the left hand side is a variable then its data and shape are rewritten with that of the right hand side expression. This allows the developer to change the size of an array dynamically. A static check is performed to guarantee that dimensionalities of both sides match. If a scalar is assigned to an array, the assignment is performed point-wise.</p>
<p>Listing 1: Examples of array assignments </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> [[1]] full; <span class="comment">// empty right now</span></div><div class="line"><span class="keywordtype">int</span> [[1]] arr (10);</div><div class="line">full = arr; <span class="comment">// no longer empty</span></div><div class="line">arr = 1; <span class="comment">// all values set to 1</span></div></div><!-- fragment --><h2><a class="anchor" id="array_expressions"></a>
Array expressions</h2>
<p>Arithmetic, logical and relational operations all operate point-wise on arrays. Additionally, where context allows, scalar values are converted into properly sized arrays implicitly. For example scalars at right hand side of array assignment expressions are converted to constant arrays, and all arithmetic, relational and boolean operators convert scalars to arrays implicitly.</p>
<p>Listing 2: Array expressions </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> [[1]] a (10);</div><div class="line"><span class="keywordtype">int</span> [[1]] b (10);</div><div class="line"><span class="comment">// point -wise operations :</span></div><div class="line">a = b + b;</div><div class="line">++ a;</div><div class="line"><span class="comment">// implicit conversions :</span></div><div class="line">b = 2 * a;</div><div class="line">a = 5;</div></div><!-- fragment --><h2><a class="anchor" id="indexing_arrays"></a>
Indexing arrays</h2>
<p>Indexing of arrays is performed by writing a comma separated list of indices between square brackets after an expression. It’s statically checked that number of indices is equal to the dimensionality of the array being indexed, and that all indices are signed integers of a public security type. Dynamic checks are performed to guarantee that indices are within array bounds. Indexing of variables may also be performed in the left hand side of an assignment. Let us first consider the case of indexing a single dimensional array. Indexing with a public integer returns a value in the array at that position, if it is within the bounds. Run-time error is raised otherwise. Like in C, indices always start at zero.</p>
<p>Listing 3: Indexing </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> [[1]] arr (5) = 1;</div><div class="line"><span class="keywordtype">int</span> val = arr [0]; <span class="comment">// val == 1</span></div><div class="line">arr [1] = 0; <span class="comment">// second element of arr is now 0</span></div></div><!-- fragment --><p>Any index is allowed to be a slice by denoting it by a colon : separated lower and an upper bound expressions. A slice defines an interval of indices which includes the lower bound of the slice, but excludes the upper bound. The returned value is an array with elements taken from the original array falling between the bounds denoted by that slice. A dynamic check is performed to ensure that all of the elements denoted by the slice are within array bounds. Another way of using slice indexing is in the left hand side of an assignment in which case the region specified by indices is overwritten by the value of the right-hand-side. The assignment is only performed if the shapes of both sides match (an error is raised otherwise). The assignment of a scalar value has the expected point-wise behavior.</p>
<p>Listing 4: Indexing with slices </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> [[1]] arr (5);</div><div class="line">arr [1:4] = 1;</div><div class="line">arr [2:3] = 2;</div><div class="line"><span class="comment">// arr == [0 ,1 ,2 ,1 ,0]</span></div></div><!-- fragment --><p>There is also some syntactic sugar associated with array slices. If the lower bound of a slice is missing, it is taken to be the constant zero, if an upper bound is missing, the size of the array is used. For example, indexing a one-dimensional array with just a colon returns a copy of the original array.In case of multiple indices, the indexing is performed on all of the dimensions in a natural manner. A nice property of our approach is that it is possible to compute the resulting dimensionality of the expression by simply counting the number of slices that the array has been indexed with. Note, that indexing an array multiple times does not have the same effect as in C. For example, if mat is a two-dimensional array, then the expression mat[0][0] does not type check as mat has to be indexed with two indices while only one is given. The type-correct expression would be mat[0, 0]. Chaining indices is still possible. For example, given a vector vec the expression vec[1:][2] is completely legal and returns the fourth element of the vector.</p>
<h2><a class="anchor" id="array_primitives"></a>
Array Primitives</h2>
<p>In addition to the indexing operators, there are four additional built-in constructs for manipulating arrays. </p><pre class="fragment">    size
</pre><p>Returns the number of elements in the argument array as a public integer. Size can be called on expressions of any type. Computing the size of an array takes—in the worst case— a linear number of multiplications in the number of dimensions. If invoked on scalars the size expression always evaluates to 1, and the subexpression will be evaluated.</p>
<p>Listing 5: Size expression </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> [[3]] arr (2, 3, 5);</div><div class="line"><span class="comment">// size (arr) == 2*3*5</span></div><div class="line"><span class="keywordtype">int</span> [[1]] empty ;</div><div class="line"><span class="comment">// size ( empty ) == 0</span></div></div><!-- fragment --><p><br />
</p><pre class="fragment">    shape
</pre><p>Returns the sizes of dimensions of the argument array as a public integer vector. The type of the argument is not restricted in any way. If called on scalar value, an empty array is returned. The subexpression is always evaluated, even if the value of it is not required.</p>
<p>Listing 6: Shape expression </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> [[3]] arr (2, 3, 5);</div><div class="line"><span class="keywordtype">int</span> [[1]] s = shape (arr ); <span class="comment">// == [2, 3, 5]</span></div></div><!-- fragment --><p><br />
</p><pre class="fragment">    cat
</pre><p>Concatenates the first two argument arrays along the dimension specified by the third argument. The last argument has to be a public integer literal. The argument arrays must have equal dimensions and the same data type. The last argument has to be between zero and the number of dimensions of arguments. The last argument may be omitted in which case it is implicitly assumed to be zero.</p>
<p>Listing 7: Concatenation of arrays </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> [[1]] a (5) = 0;</div><div class="line"><span class="keywordtype">int</span> [[1]] b (5) = 1;</div><div class="line"><span class="keywordtype">int</span> [[1]] c = cat (a, b); <span class="comment">// or cat (a, b, 0)</span></div><div class="line"><span class="comment">// size (c) == 10</span></div><div class="line"><span class="comment">// c [0:5] == 0</span></div><div class="line"><span class="comment">// c [5:10] == 1</span></div></div><!-- fragment --><p>Run-time error is raised if shape of concatenated arrays does not match.</p>
<p><br />
</p><pre class="fragment">    reshape
</pre><p>Returns an array with the same data, but a different shape than the original. The first argument is the initial array and the rest of the arguments specify the new shape. A run-time check is performed to check that the number of elements in the old and new arrays are equal. The returned array inherits the values and the security type of the original array. A common idiom is to combine the use of reshape and size for flattening multi-dimensional arrays into a vector form.</p>
<p>Listing 8: Array flattening </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> [[2]] mat (5, 5);</div><div class="line"><span class="keywordtype">int</span> [[1]] arr = reshape (mat , size (mat ));</div><div class="line"><span class="comment">// size (arr) == 25</span></div></div><!-- fragment --><p>It is possible to use reshape to create a temporary constant array from a scalar with fixed size. This supplies a convenient tool for changing both the size and value of an already created array, or for constructing temporary constant arrays of given size.</p>
<p>Listing 9: Temporary constant array </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> [[1]] arr (100);</div><div class="line"><span class="comment">// some computation on arr</span></div><div class="line">arr = reshape (1, 10);</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 5 2018 17:28:50 for SecreC 2 language by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
